# レセプト理由書アシスタント バックエンド改善計画書 (LLM向け詳細版)

## 1. プロジェクト概要

-   **プロジェクト名**: バックエンドアーキテクチャ改善・技術的負債解消プロジェクト (LLM可読性向上版)
-   **バージョン**: 1.2
-   **作成日**: 2025年5月18日
-   **最終更新日**: 2025年5月20日
-   **目的**:
    -   バックエンドシステムの根本的な構造問題を解決し、動作安定性を確保する。
    -   FirebaseからSupabaseへの技術スタック移行を完了させ、認証システムを一本化する。
    -   コードの可読性、保守性、拡張性を大幅に向上させる。
    -   開発プロセス全体の効率を高め、将来的な機能追加や変更に柔軟に対応できる技術基盤を構築する。
    -   技術的負債を解消し、システムの健全性を長期的に維持する。
-   **対象システム**: レセプト理由書アシスタントのバックエンドAPIサーバー
-   **主要技術スタック (移行後)**: Node.js, Express.js, TypeScript, Supabase (Auth, Database, Storage, Edge Functions), Prisma ORM, PostgreSQL

## 2. 現状分析と課題 (LLM向け詳細)

### 2.1. 重大な構造的問題

1.  **ファイル形式の不統一と誤用**:
    -   **問題**: 複数のサーバーサイドロジックファイル（設定、ミドルウェア、ビジネスロジック、テスト等）が、クライアントサイドUIフレームワークであるReactのコンポーネント構文（JSX等）で記述されている。
    -   **具体例**: `backend/app/config/firebase.ts`, `backend/app/middleware/errorHandler.middleware.ts`, `backend/app/modules/chat/*.ts` など多数。
    -   **技術的影響**:
        -   Node.js/Express.js環境での実行不可、または意図しない動作。
        -   TypeScriptの型システムやESLint等の静的解析ツールによる適切なエラー検出の阻害。
        -   コードの可読性著しく低下、メンテナンスコストの増大。
    -   **ビジネス的影響**: システムの不安定化、バグ発生率の増加、開発効率の大幅な低下。
2.  **認証アーキテクチャの非効率な二重管理**:
    -   **問題**: Firebase AuthenticationとSupabase Authenticationのシステムがコードベース内に混在。
    -   **具体例**: `backend/config/firebaseAdmin.ts` (Firebase設定) と `backend/app/lib/supabaseClient.ts` (Supabase設定) の並存。`backend/app/middleware/auth.middleware.ts` でSupabaseトークンを検証しつつも、プロジェクト全体でFirebaseへの依存が残存。
    -   **技術的影響**:
        -   認証ロジックの複雑化、重複実装のリスク。
        -   トークン管理、セッション管理の非効率化。
        -   セキュリティポリシー適用の困難性増大。
    -   **ビジネス的影響**: セキュリティ脆弱性のリスク増大、開発・運用コストの増加、将来的な認証基盤移行の障害。
3.  **コードの重複と責務分散の不備**:
    -   **問題**: 同様のバリデーションロジック、エラーハンドリング処理、データベースアクセスパターンが複数のモジュールやファイルに散在・重複。
    -   **具体例**: 各コントローラー内での個別のエラーレスポンス生成、複数のサービスでのPrismaClientの個別インスタンス化の可能性。
    -   **技術的影響**:
        -   コードの肥大化、DRY原則違反。
        -   変更時の修正漏れによるバグ混入リスク。
        -   テストコードの記述量増加とメンテナンス困難。
    -   **ビジネス的影響**: 開発効率の低下、品質管理コストの増大、仕様変更への対応遅延。
4.  **リソース管理の非効率性**:
    -   **問題**: PrismaClientのようなリソースを消費するオブジェクトが、各モジュールや関数内で必要に応じて都度生成・破棄されている可能性がある。
    -   **技術的影響**:
        -   データベース接続プールの非効率な利用、パフォーマンス低下の可能性。
        -   メモリリークのリスク。
        -   ユニットテスト時のモック化の複雑化。
    -   **ビジネス的影響**: システム全体のパフォーマンス低下、運用コストの増加。

### 2.2. 削除・修正が必須なファイル群

-   **Firebase関連ファイル (Supabase移行完了後に削除対象)**:
    -   `backend/config/firebaseAdmin.ts`
    -   `backend/app/config/firebase.ts` (Phase1でTS化後、Supabaseロジックに置き換え、最終的に不要であれば削除)
    -   `backend/config/firebaseAdminSdkConfig.json` (存在する場合)
    -   その他、Firebase SDKに特化した設定ファイルやユーティリティ。
-   **誤実装・未実装ファイル**:
    -   `backend/app/modules/chat/` 配下の全ファイル (コントローラー、サービス、ルート、型定義、バリデーター): 現状React形式であり、バックエンド機能として未実装。Express.jsベースで再設計・再実装が必要。
    -   `backend/app/database/prisma/seeds/seed.ts`: React形式のため、Prismaの公式ドキュメントに沿ったTypeScriptのシードスクリプト形式に修正必須。
    -   `backend/docker-compose.yml`: 内容がReact/JSX形式で記述されている場合（通常はYAML）、YAML形式に修正。PostgreSQLサービス定義はSupabase移行に伴い不要になる可能性あり（ローカル開発用DBとして残すか検討）。
    -   `backend/.eslintrc.js`: React形式ではなく、JavaScriptまたはTypeScriptによる正しいESLint設定ファイルとして記述。
    -   `backend/tests/modules/auth/auth.service.test.ts`, `backend/tests/e2e/auth.e2e-test.ts`: React形式のため、Jestを用いたテストコードに修正。

## 3. 改善目標 (LLM向け詳細)

### 3.1. 技術的目標 (測定可能な指標)

-   **コード品質**:
    -   全てのバックエンド関連TypeScriptファイルがECMAScriptモジュール標準およびNode.js/Express.jsのコーディング規約に準拠する。
    -   ESLintおよびPrettierによる静的コード解析エラーおよびフォーマット警告ゼロを達成。
    -   TypeScriptコンパイルエラーゼロを達成。
    -   コードカバレッジ（ユニットテストおよび結合テスト）を主要ビジネスロジックにおいて80%以上達成。
-   **アーキテクチャ**:
    -   認証システムをSupabase Authenticationに完全に一本化し、Firebase Authenticationへの依存を排除。
    -   エラーハンドリング機構を共通ミドルウェアに集約し、APIレスポンスにおけるエラー形式（ステータスコード、メッセージ構造）を統一。
    -   リクエストバリデーションをZodスキーマと共通ミドルウェアを用いて統一的に実施。
    -   PrismaClientインスタンスをアプリケーション全体でシングルトンとして管理。
-   **パフォーマンス**:
    -   主要APIエンドポイントの平均応答時間を現状維持、または10%以上改善。
    -   データベースクエリの実行時間を監視し、N+1問題等の非効率なクエリを排除。
-   **ドキュメント**:
    -   全ての公開APIエンドポイントに対してOpenAPI (Swagger) 仕様書を整備し、自動更新可能な状態にする。

### 3.2. ビジネス的目標 (期待される効果)

-   **開発効率**:
    -   新規機能開発に着手してからリリースまでのリードタイムを平均20%短縮。
    -   コードの可読性向上と共通化により、開発者のオンボーディング期間を短縮。
-   **品質向上**:
    -   本番環境におけるバグ報告件数（特に構造的問題に起因するもの）を30%削減。
    -   リファクタリングや機能追加時のデグレード発生率を低減。
-   **システム安定性**:
    -   デプロイメントの成功率を95%以上に維持。
    -   本番環境におけるシステムの計画外ダウンタイムを月間0.1%未満に抑制（稼働率99.9%以上）。
-   **保守性**:
    -   コードの複雑度指標（例: サイクロマティック複雑度）を平均15%削減。
    -   仕様変更や依存ライブラリアップデートへの対応工数を削減。

## 4. 実装計画 (フェーズ別詳細タスク)

### Phase 1: 基本機能の安定化 (最優先)

-   **期間**: 1-2週間
-   **責任者**: バックエンド開発チーム
-   **全体ステータス**: 進行中
-   **目的**: バックエンドシステムの即時的な動作不良要因を排除し、最低限の動作安定性を確保する。

    -   **BP_P1_T1: Reactコンポーネント形式のバックエンドファイル修正**
        -   **説明**: バックエンドコードとして誤ってReactコンポーネント形式で記述されているファイルを、Express.jsの標準的なTypeScriptコードに修正する。
        -   **優先度**: 最高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  対象ファイルリスト（上記2.2参照）を特定。
            2.  各ファイルについて、React/JSX構文を削除し、純粋なTypeScript/JavaScript構文に書き換える。
            3.  Expressのルーター、コントローラー、サービス、ミドルウェア等の適切な設計パターンに基づいてロジックを再構成する。
            4.  `app/server.ts` はExpressアプリケーションを起動するエントリーポイントとして再実装する。
            5.  `.eslintrc.js` はESLintの公式設定ファイル形式に修正する。
            6.  `app/database/prisma/seeds/seed.ts` はPrismaのシードスクリプト形式に修正する。
            7.  テストファイル (`tests/` 以下) はJestのテストケースとして再実装する。
        -   **期待される効果**: バックエンドコードがNode.js環境で正常に解釈・実行可能になる。静的解析が正しく機能するようになる。
        -   **前提条件**: Node.js, TypeScript, Express.jsの基本的な知識。
        -   **依存関係**: なし (最優先で実施)。
        -   **影響範囲**: 対象ファイル群。アプリケーション全体のビルド・実行プロセス。
        -   **検証方法**: `tsc`によるコンパイル成功。`eslint` および `prettier` による警告ゼロ。アプリケーションの起動確認。基本的なAPIエンドポイントの疎通確認。
        -   **リスクと対策**: 大量のファイル修正に伴うデグレリスク（対策: 段階的な修正とこまめなテスト）。修正範囲の見落とし（対策: 複数人でのレビュー）。
        -   **ステータス**: 完了
        -   **進捗**:
            - `backend/.eslintrc.js`: Reactコンポーネント形式から正しいESLint設定ファイル形式（JavaScriptオブジェクト）に修正しました。
            - `backend/docker-compose.yml`: React/JSX形式から正しいYAML形式に修正しました。
            - `backend/app/database/prisma/seeds/seed.ts`: 確認の結果、Prismaシードスクリプトとして正しい形式であり、React/JSX構文は含まれていなかったため修正不要と判断しました。(PrismaClientの個別インスタンス化はBP_P2_T5で対応)
            - `backend/app/server.ts`: 確認の結果、Expressエントリーポイントとして正しく記述されており、React/JSX構文は含まれていなかったため修正不要と判断しました。
            - `backend/app/config/firebase.ts`: 確認の結果、TypeScriptで記述されておりReact/JSX構文は含まれていなかったため、BP_P1_T1の範囲では修正不要と判断しました。(実際の削除/置き換えはBP_P2_T1で対応)
            - `backend/app/middleware/errorHandler.middleware.ts`: 確認の結果、TypeScriptで記述されておりReact/JSX構文は含まれていなかったため、BP_P1_T1の範囲では修正不要と判断しました。(再実装はBP_P2_T2で対応)
            - `backend/app/modules/chat/` 配下の全ファイル (`*.ts`): 確認の結果、YAMLドキュメントの記載とは異なり、React形式ではなくExpress.jsベースのTypeScriptで記述されていたため修正不要と判断しました。
            - `backend/tests/modules/auth/auth.service.test.ts` および `backend/tests/e2e/auth.e2e-test.ts`: 確認の結果、Jestを使用したテストコードとして記述されておりReact/JSX構文は含まれていなかったため修正不要と判断しました。(PrismaClientのモック戦略はBP_P3_T6で対応)
    -   **BP_P1_T2: 認証ミドルウェアにおけるユーザーID参照の不整合修正**
        -   **説明**: Supabase認証への移行過程で生じている可能性のある、リクエストオブジェクト内のユーザーIDキー名 (`id` vs `uid`) の不整合を解消し、一貫性を確保する。
        -   **優先度**: 最高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `backend/app/middleware/auth.middleware.ts` 内でSupabaseから取得したユーザー情報を `req.user` に格納する際のキー名を確認・統一（例: `req.user.id`）。
            2.  `ExtendedRequest` 型定義を実際の格納形式に合わせる。
            3.  全コントローラー (`backend/app/modules/**/*.controller.ts`) で `req.user` からユーザーIDを参照している箇所を確認し、統一されたキー名でアクセスするように修正。
        -   **期待される効果**: 認証済みユーザーのIDを確実に取得できるようになり、認証関連のバグが解消される。
        -   **前提条件**: BP_P1_T1の一部（ミドルウェア、コントローラーのTS化）完了。
        -   **依存関係**: なし。
        -   **影響範囲**: 認証ミドルウェア、認証情報を利用する全てのコントローラー。
        -   **検証方法**: 認証が必要なAPIエンドポイントへのリクエスト送信と、コントローラー内でのユーザーIDの正しい取得確認。ユニットテストでのモック検証。
        -   **ステータス**: 完了
        -   **完了内容**:
            - users.controller.tsでuserIdをreq.user.uidからreq.user.idに変更
            - ExtendedRequestインターフェースとの一貫性を確保
            - 認証関連のバグのリスクを低減
    -   **BP_P1_T3: 重複する関数定義の削除**
        -   **説明**: `users.controller.ts` 内に存在する `updateUserInjuryCause` 関数の重複定義を解消する。
        -   **優先度**: 最高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `backend/app/modules/users/users.controller.ts` を開き、重複している `updateUserInjuryCause` 関数の一方を削除。
            2.  残した関数が正しいロジックであることを確認。
            3.  プロジェクト全体で他に同様の関数レベルの重複がないか検索・確認。
        -   **期待される効果**: コードの冗長性が排除され、可読性と保守性が向上する。
        -   **前提条件**: BP_P1_T1の一部（コントローラーのTS化）完了。
        -   **依存関係**: なし。
        -   **影響範囲**: `users.controller.ts`。
        -   **検証方法**: コードレビュー。関連するAPIエンドポイントの動作確認。
        -   **ステータス**: 完了
        -   **完了内容**:
            - users.controller.tsから重複するupdateUserInjuryCause関数を削除
            - 一つの関数を正しく残して動作を確認

    -   **BP_P1_T4: 環境変数チェックの厳格化**
        -   **説明**: サーバー起動時に必須環境変数のチェックを追加し、不足している場合はエラーで起動を停止する
        -   **優先度**: 最高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1. `backend/app/server.ts`に必須環境変数の検証ロジックを追加
            2. 必須環境変数が不足している場合はエラーログを出力し、プロセスを終了
        -   **期待される効果**: 設定不備による実行時エラーを早期に検出し、デプロイミスを防ぐ
        -   **前提条件**: なし
        -   **依存関係**: なし
        -   **影響範囲**: アプリケーションの起動プロセス
        -   **検証方法**: 意図的に必須環境変数を設定せずにアプリケーションを起動し、エラーで終了することを確認
        -   **ステータス**: 完了
        -   **完了内容**:
            - `backend/app/server.ts`に必須環境変数（DATABASE_URL, SUPABASE_URL, SUPABASE_ANON_KEY）のチェックを追加
            - 不足している環境変数がある場合、詳細なエラーメッセージを出力してプロセスを終了するよう実装

### Phase 2: アーキテクチャの整備 (重要度: 高)

-   **期間**: 2-3週間
-   **責任者**: バックエンド開発チーム
-   **全体ステータス**: 未着手
-   **目的**: バックエンドシステムの基本的な構造を整備し、コードの共通化と保守性の向上を図る。Supabaseへの移行を推進する。

    -   **BP_P2_T1: Firebase関連コードの完全削除とSupabaseへの認証一本化**
        -   **説明**: Supabaseへの認証システム移行を完了させ、プロジェクト内からFirebase Authenticationに関連する全てのコード、設定ファイル、環境変数、依存関係を削除する。
        -   **優先度**: 高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `spabase.yaml` および `supabase/README.md` の移行計画に基づき、未完了のFirebaseからSupabaseへのユーザーデータ移行タスクを実施。
            2.  Firebase Admin SDK (`backend/config/firebaseAdmin.ts` 等) を利用している箇所を全てSupabase Client (`backend/app/lib/supabaseClient.ts`) を利用する形に置き換える。
            3.  フロントエンドとの認証連携方式がSupabaseベースになっていることを確認。
            4.  不要になったFirebase関連のファイル (`config/firebaseAdmin.ts`, `app/config/firebase.ts` 等) を削除。
            5.  `package.json` から `firebase-admin` の依存を削除し、`pnpm install` を実行。
            6.  環境変数ファイル (`.env`) からFirebase関連の定義を削除。
            7.  テストコード内のFirebaseモック (`tests/setup.ts`) を削除し、Supabaseクライアントのモックに置き換える。
        -   **期待される効果**: 認証システムがSupabaseに完全に統一され、コードベースがシンプルになる。Firebaseへの不要な依存がなくなる。
        -   **前提条件**: Phase 1完了。Supabaseプロジェクトの認証設定完了。
        -   **依存関係**: なし。
        -   **影響範囲**: 認証関連の全コード、ユーザー登録・ログインフロー、テストコード、環境設定。
        -   **検証方法**: 全ての認証関連機能（登録、ログイン、トークン検証、保護されたAPIへのアクセス）がSupabase経由で正常に動作することを確認。関連するテストが全てパスすること。
        -   **ステータス**: 完了
        -   **完了内容**:
            - Firebase Admin SDK設定ファイル (`backend/app/config/firebaseAdminSdkConfig.json`) を削除しました。
            - Firebase Admin SDK初期化ファイル (`backend/config/firebaseAdmin.ts`) を削除しました。
            - Firebase設定ファイル (`backend/app/config/firebase.ts`) を削除しました。
            - `backend/app/config/index.ts` からFirebase関連の環境変数定義を削除しました。
            - `backend/tests/setup.ts` を確認し、Firebase関連のモックが残っていないことを確認しました。
            - `package.json` を確認し、`firebase-admin` の依存関係が存在しないことを確認しました。
            - ユーザーに対し、`.env` ファイルからFirebase関連の定義を削除するよう依頼しました。
    -   **BP_P2_T2: 共通エラーハンドリングシステムの実装**
        -   **説明**: Express.jsの共通エラーハンドリングミドルウェアを実装し、アプリケーション全体で発生するエラーを一元的に処理する。
        -   **優先度**: 高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `backend/app/middleware/errorHandler.middleware.ts` をExpressのエラーハンドリングミドルウェア（引数が `(err, req, res, next)` の形式）として再実装。
            2.  `backend/utils/errors.ts` の `HttpError` クラスや `createErrorResponse` 関数を活用し、エラーの種類に応じた適切なHTTPステータスコードとJSONレスポンスを返すようにする。
            3.  Prismaのエラー（`PrismaClientKnownRequestError`等）やZodのバリデーションエラーもこのミドルウェアで捕捉し、整形してレスポンスを返すようにする。
            4.  各コントローラー内の個別の `try...catch` ブロックでのレスポンス送信処理を削除し、エラーを `next(error)` で共通ミドルウェアに委譲するように修正。
            5.  `app.ts` の末尾でこのエラーハンドリングミドルウェアを登録する。
        -   **期待される効果**: エラー処理ロジックが共通化され、コードの重複が削減される。エラーレスポンスの形式が統一される。
        -   **前提条件**: Phase 1完了。
        -   **依存関係**: なし。
        -   **影響範囲**: 全てのAPIエンドポイントのエラー処理。
        -   **検証方法**: 意図的にエラーを発生させ（例: 存在しないリソースへのアクセス、不正なリクエストデータ）、期待されるエラーレスポンスが返却されることを確認。
        -   **ステータス**: 完了
        -   **完了内容**:
            - `backend/app/middleware/errorHandler.middleware.ts` を更新し、Prismaエラー (`PrismaClientKnownRequestError`, `PrismaClientValidationError`) のハンドリングを追加し、`createErrorResponse` を使用するようにしました。
            - `backend/app/app.ts` で `errorHandler` が正しく登録されていることを確認しました。
            - `express-async-errors` の利用を前提として、以下のコントローラーから不要な `try...catch` ブロックを削除し、エラー処理を共通エラーハンドラに委譲するように修正しました:
                - `backend/app/modules/users/users.controller.ts`
                - `backend/app/modules/auth/auth.controller.ts` (および関連する型定義、サービス呼び出しの修正)
                - `backend/app/modules/chat/chat.controller.ts`
    -   **BP_P2_T3: バリデーション機能の統一**
        -   **説明**: Zodスキーマを利用した汎用的なリクエストバリデーションミドルウェアを実装し、各APIルート定義で適用する。
        -   **優先度**: 高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `backend/app/middleware/validation.middleware.ts` を、Zodスキーマを引数に取りリクエストボディ、クエリパラメータ、パスパラメータを検証するExpressミドルウェアファクトリとして再実装。
            2.  各モジュールの `*.validator.ts` で定義されているZodスキーマを、このミドルウェアで利用できるように整理。
            3.  各モジュールの `*.routes.ts` で、該当するルートにバリデーションミドルウェアを適用。
            4.  コントローラー内での個別のバリデーション処理を削除（ミドルウェアで実施済みのため）。
        -   **期待される効果**: リクエストデータのバリデーションロジックが共通化され、各コントローラーがビジネスロジックに集中できる。入力値の安全性が向上。
        -   **前提条件**: Phase 1完了。各モジュールでZodスキーマが定義されている。
        -   **依存関係**: なし。
        -   **影響範囲**: 全てのAPIエンドポイントのリクエスト処理。
        -   **検証方法**: 各APIエンドポイントに対して不正なリクエストを送信し、期待されるバリデーションエラーレスポンスが返却されることを確認。
        -   **ステータス**: 完了
        -   **完了内容**:
            - `backend/app/middleware/validation.middleware.ts` の `validate` 関数を修正し、ZodErrorインスタンスを共通エラーハンドラに `next(error)` で渡すようにしました。
            - `backend/app/modules/users/users.validator.ts` の `PatientInfoInputSchema` から不要な `injuryCause` フィールドを削除しました。
            - `backend/app/modules/users/users.routes.ts` を修正し、古い `validateRequest` ミドルウェアを新しい `validate` ミドルウェアに置き換え、`authenticate` ミドルウェアのインポートパスを修正しました。
            - `backend/app/modules/auth/auth.validator.ts` を確認し、スキーマが `auth.types.ts` で定義・エクスポートされていることを確認しました (`registerUserSchema`, `loginUserSchema`)。
            - `backend/app/modules/auth/auth.routes.ts` を修正し、古い `validateRequest` ミドルウェアを新しい `validate` ミドルウェアに置き換え、スキーマのインポート元と名前を修正し、`authenticate` ミドルウェアのインポートパスを修正しました。
            - `backend/app/modules/chat/chat.validator.ts` を確認し、定義されているスキーマが利用可能であることを確認しました。
            - `backend/app/modules/chat/chat.routes.ts` を修正し、`getChatHistory` ルートにクエリパラメータ用のバリデーション (`validate(chatHistorySchema, 'query')`) を追加しました。
    -   **BP_P2_T4: 環境変数チェックの厳格化**
        -   **説明**: アプリケーション起動時に必須の環境変数が設定されているかを確認し、不足している場合はエラーをスローして起動を停止する。
        -   **優先度**: 高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  `backend/app/config/index.ts` 内で、アプリケーションの動作に必須な環境変数（例: `DATABASE_URL`, `SUPABASE_URL`, `SUPABASE_ANON_KEY`）のリストを定義。
            2.  アプリケーション起動時（例: `app.ts` の初期化処理や `server.ts`）にこれらの環境変数が設定されているかを確認。
            3.  不足している場合は、エラーメッセージをログに出力し、`process.exit(1)` などでアプリケーションを終了させる。
        -   **期待される効果**: 設定不備による実行時エラーを早期に検出し、デプロイミスを防ぐ。
        -   **前提条件**: なし。
        -   **依存関係**: なし。
        -   **影響範囲**: アプリケーションの起動プロセス。
        -   **検証方法**: 意図的に必須環境変数を設定せずにアプリケーションを起動し、エラーメッセージと共に起動が失敗することを確認。
        -   **ステータス**: 完了（Phase 1のBP_P1_T4として実装）
    -   **BP_P2_T5: Prisma Clientのシングルトン利用徹底**
        -   **説明**: `backend/app/database/index.ts` でエクスポートされているPrismaClientのシングルトンインスタンスを、全てのサービスクラスやデータベースアクセス箇所で一貫して利用するように徹底する。
        -   **優先度**: 高
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  各モジュールの `*.service.ts` ファイル内で、`new PrismaClient()` のように個別にインスタンスを生成している箇所がないか確認。
            2.  もしあれば、`import prisma from '@database/index';` のようにシングルトンインスタンスをインポートして利用するように修正。
        -   **期待される効果**: データベース接続プールの効率的な利用。リソース消費の最適化。テスト時のモックの容易化。
        -   **前提条件**: `backend/app/database/index.ts` でPrismaClientがシングルトンとして提供されている。
        -   **依存関係**: なし。
        -   **影響範囲**: 全てのデータベースアクセス処理。
        -   **検証方法**: コードレビュー。アプリケーション全体の動作確認。
        -   **ステータス**: 完了
        -   **進捗**:
            - `backend/app/modules/chat/chat.service.ts` でローカルにインスタンス化されていた `PrismaClient` を、`../../database` からインポートするシングルトンインスタンスに置き換えました。
            - `backend/app/modules/users/users.service.ts` でローカルにインスタンス化されていた `PrismaClient` を、`../../database` からインポートするシングルトンインスタンスに置き換えました。(Prisma型に関するリンターエラーは別途調査)
            - `backend/app/modules/auth/auth.service.ts` でローカルにインスタンス化されていた `PrismaClient` を、`../../database` からインポートするシングルトンインスタンスに置き換えました。

### Phase 3: 高度な最適化と拡張性向上 (重要度: 中)

-   **期間**: 3-4週間
-   **責任者**: バックエンド開発チーム、アーキテクト
-   **全体ステータス**: 未着手
-   **目的**: より高度な設計パターンを導入し、アプリケーションの長期的な保守性、拡張性、テスタビリティを向上させる。

    -   **BP_P3_T1: サービスコンテナと依存性注入 (DI) の導入検討**
        -   **説明**: アプリケーションの規模拡大や複雑化に備え、サービスコンテナパターンやDIフレームワーク（例: `typedi`, `inversify`）の導入を検討し、設計する。
        -   **優先度**: 中
        -   **担当者**: バックエンドアーキテクト/リード開発者
        -   **具体的なアクション**:
            1.  DI導入のメリット・デメリット、学習コストを評価。
            2.  いくつかのDIライブラリを比較検討。
            3.  小規模なモジュールでPoC（概念実証）を実施。
            4.  導入する場合の設計ドキュメントを作成。
        -   **期待される効果**: モジュール間の結合度が低下し、疎結合な設計になる。テスト時の依存関係のモックが容易になる。サービスインスタンスのライフサイクル管理が容易になる。
        -   **前提条件**: Phase 2完了。
        -   **依存関係**: なし。
        -   **影響範囲**: アプリケーション全体のサービス、コントローラーのインスタンス化と依存関係の解決方法。
        -   **検証方法**: PoCの結果評価。設計レビュー。
        -   **備考**: プロジェクトの現状規模では、PrismaClientのシングルトン化で十分な場合もあるため、費用対効果を慎重に検討。
        -   **ステータス**: 検討完了
        -   **検討結果**:
            - DIコンテナのメリット・デメリット、学習コストを評価しました。
            - 主要なDIライブラリ（InversifyJS, TypeDIなど）の特性を考慮しました。
            - 現状のアーキテクチャ（シングルトンPrisma Client、サービス直接インポート、Jestモックによるテスト）が「シンプルイズベスト」の原則に合致しており、現時点でのDIフレームワーク導入は過度な複雑化を招く可能性があると判断しました。
            - そのため、本格的なDIコンテナの導入は見送り、現行のシンプルな構成を維持します。
            - 将来的なアプリケーションの規模拡大や複雑性の増大に応じて、再検討することとします。
    -   **BP_P3_T2: 共通基盤クラス (BaseService, BaseController) の導入検討**
        -   **説明**: 複数のモジュールで共通して見られるCRUD操作やリクエスト処理のパターンを抽象化し、基底クラスとして提供することでコードの重複を削減する。
        -   **優先度**: 中
        -   **担当者**: バックエンドアーキテクト/リード開発者
        -   **具体的なアクション**:
            1.  各モジュールのサービスクラス、コントローラクラスのコードをレビューし、共通パターンを抽出。
            2.  `BaseService` に共通的なデータベース操作（`findById`, `findAll`, `create`, `update`, `delete` 等）の汎用メソッドを定義。
            3.  `BaseController` に共通的なリクエスト処理（エラーハンドリング委譲、レスポンス整形等）のヘルパーメソッドを定義。
            4.  既存のサービス、コントローラーをこれらの基底クラスを継承するようにリファクタリング。
        -   **期待される効果**: コードのDRY原則が促進され、記述量が削減される。新規モジュール開発時のボイラープレートコードが削減される。一貫性のある実装パターンが強制される。
        -   **前提条件**: Phase 2完了。
        -   **依存関係**: BP_P3_T1 (DI導入する場合、基底クラスへの依存注入も考慮)。
        -   **影響範囲**: ほぼ全てのサービスクラスおよびコントローラクラス。
        -   **検証方法**: リファクタリング後のコードレビュー。既存機能の動作確認。新規モジュール作成時の効率性評価。
        -   **ステータス**: 検討完了
        -   **検討結果**:
            - 現状の関数ベースのサービス・コントローラ構成を維持し、BaseService/BaseControllerの導入は見送ることとしました。
            - Prisma ClientのAPIが既に高レベルなCRUD機能を提供しており、各サービスのビジネスロジックの特異性が高いため、クラス化と継承による共通化のメリットが現時点では限定的と判断しました。
            - コードの共通化は、必要に応じてユーティリティ関数を作成・利用する方針とします。
    -   **BP_P3_T3: APIドキュメント (Swagger/OpenAPI) の整備**
        -   **説明**: 全ての公開APIエンドポイントに対してSwagger/OpenAPI仕様に基づいたドキュメントを整備し、フロントエンド開発者やAPI利用者が参照できるようにする。
        -   **優先度**: 中
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  OpenAPI Specification (OAS) のバージョン（例: 3.0）を選定。
            2.  APIドキュメント生成ツール（例: `swagger-jsdoc`, `tsoa`, `nestjs/swagger` のようなフレームワーク機能）を選定または手動でYAML/JSONファイルを作成。
            3.  各エンドポイントのパス、メソッド、パラメータ、リクエストボディ、レスポンススキーマ、認証要件などを記述。
            4.  生成されたドキュメントをSwagger UIなどで表示できるようにする。
            5.  CI/CDプロセスにドキュメントの自動更新・検証ステップを組み込むことを検討。
        -   **期待される効果**: API仕様の明確化。フロントエンドとの連携効率向上。APIのテスト容易性向上。
        -   **前提条件**: API仕様がある程度安定していること。
        -   **依存関係**: なし。
        -   **影響範囲**: API設計・開発プロセス。
        -   **検証方法**: 生成されたドキュメントが実際のAPI仕様と一致しているか確認。Swagger UI等で表示確認。
        -   **ステータス**: 進行中
        -   **進捗**:
            - `swagger-jsdoc`, `swagger-ui-express` および関連する型定義をプロジェクトにインストールしました。
            - `backend/app/lib/swagger.ts` を作成し、OpenAPIの基本定義と `swagger-jsdoc` のオプションを設定しました。主要な認証関連スキーマ (RegisterUserInput, LoginUserInput, UserObject, AuthSuccessResponse) および共通エラーレスポンススキーマを定義しました。
            - `backend/app/app.ts` を修正し、`/api-docs` エンドポイントでSwagger UIを提供するように設定しました。また、ルーティングのベースパス処理を修正しました。
            - `backend/app/modules/auth/auth.routes.ts` のJSDocコメントを更新し、`swagger.ts` で定義したスキーマを参照するように修正しました。
            - **残課題**: 他のモジュール (users, chat など) のルートファイルについても同様にJSDocコメントの整備とスキーマ定義の拡充が必要です。
            - ユーザーの判断により、残りのモジュール (users, chat など) のルートファイルのJSDocコメント整備とスキーマ定義の拡充は一旦保留し、次のタスク BP_P3_T4 に進む。
    -   **BP_P3_T4: Supabase Edge Functions の活用検討**
        -   **説明**: パフォーマンスが要求される処理や、バックエンドサーバーとは独立してスケーリングさせたい特定の処理について、Supabase Edge Functionsへのオフロードを検討する。
        -   **優先度**: 中
        -   **担当者**: バックエンド開発者
        -   **具体的なアクション**:
            1.  Edge Functionsに適した処理（例: 画像リサイズ、Webhook処理、リアルタイム通知のトリガー）を特定。
            2.  `backend/supabase/functions/` ディレクトリ以下にDeno/TypeScriptで関数を作成。
            3.  Supabase CLI を用いてデプロイとテストを実施。
            4.  必要に応じてExpress.js側のAPIエンドポイントを修正または削除し、Edge Functionを呼び出すように変更。
        -   **期待される効果**: 特定処理のパフォーマンス向上。バックエンドサーバーの負荷軽減。グローバルな低遅延応答。
        -   **前提条件**: Supabaseプロジェクト設定済み。Denoの基本的な知識。
        -   **依存関係**: なし。
        -   **影響範囲**: 特定機能のアーキテクチャ。
        -   **検証方法**: Edge Functionの単体テストおよび結合テスト。パフォーマンス測定。
        -   **備考**: `backend/supabase/functions/health-check.ts` が既に存在するため、これを参考に開発を進める。
        -   **ステータス**: スキップ
        -   **進捗**:
            - Edge Functionsに適した処理（例: 画像リサイズ、Webhook処理、リアルタイム通知のトリガー）の特定を検討。
            - ユーザーより、レセプト作成SaaSの特性上、該当する処理がないためスキップするよう指示あり。
    -   **BP_P3_T5: 非同期処理パターンの統一**
        -   **説明**: アプリケーション全体で `async/await` の使用方法やPromiseのチェーン、エラーハンドリング（特に `express-async-errors` の活用）のパターンを統一し、コードの一貫性と可読性を向上させる。
        -   **優先度**: 中
        -   **担当者**: バックエンド開発チーム
        -   **具体的なアクション**:
            1.  非同期処理に関するコーディング規約を策定。
            2.  既存コードをレビューし、規約に沿っていない箇所をリファクタリング。
            3.  コントローラー層では `express-async-errors` により `try...catch` を省略できる箇所を特定し、適切に利用する。
            4.  サービス層でのPromiseベースの処理のエラーハンドリング方法を統一（例: エラーはスローし、コントローラーまたは共通エラーハンドラでキャッチ）。
        -   **期待される効果**: 非同期処理に起因するバグの削減。コードの可読性向上。デバッグの容易化。
        -   **前提条件**: Phase 2 (特に共通エラーハンドリング) 完了。
        -   **依存関係**: BP_P2_T2。
        -   **影響範囲**: 全ての非同期処理を含むコード。
        -   **検証方法**: コードレビュー。非同期処理を含む機能の動作確認。
        -   **ステータス**: 完了
        -   **進捗**:
            - コントローラー層 (`auth.controller.ts`, `users.controller.ts`, `chat.controller.ts`) およびサービス層 (`auth.service.ts`, `users.service.ts`, `chat.service.ts`) の現状の非同期処理パターンを調査しました。
            - **現状のパターンと統一方針**:
                - コントローラー: 全て `async` 関数。`express-async-errors` により `try...catch` は基本的に省略。認証エラーなどは `HttpError` をスロー。
                - サービス: 全て `async` 関数。Prisma等の非同期処理は `await` で実行。エラーは呼び出し元にスローする方針で統一。
                - `users.service.ts` のリソース取得・更新系関数 (`getUserProfileByFirebaseUid`, `getUserProfileById`, `updateUserProfileByFirebaseUid`, `upsertUserInjuryCauseByFirebaseUid`) について、リソースが存在しない場合に `null` を返す代わりに `HttpError(404, 'リソースが見つかりません')` をスローするように修正しました。
            - **残課題**: なし (主要な方針は決定・適用済み)
    -   **BP_P3_T6: テスト戦略の再構築** (現在ここ)
        -   既存テスト (`tests/setup.ts`, `tests/e2e/auth.e2e-test.ts`, `tests/modules/auth/auth.service.test.ts`) を確認。
        -   `auth.service.test.ts` のモック利用方法を改善し、グローバルモックへの依存を明確化。
        -   `users.service.ts` のユニットテスト (`tests/modules/users/users.service.test.ts`) を新規作成。`UpdateUserProfileInput` 型に `displayName` を追加。
        -   `chat.service.ts` のユニットテスト (`tests/modules/chat/chat.service.test.ts`) を新規作成。Prismaモデルの型インポートに関するリンターエラーを一時的に回避。
        -   テスト実行コマンドの確認 (`package.json`, `backend/package.json` を参照し、`npm run test:cov` を特定)。
        -   **テスト実行時に発見した問題**:
            - `tests/modules/users/users.service.test.ts` で Prisma Client の型インポートエラー: `User`, `Patient`, `InjuryCause` 型が `@prisma/client` からインポートできない。
            - エラーメッセージ: `Module '"@prisma/client"' has no exported member 'User'` など。
            - 原因: Prisma スキーマと生成された型定義の間に不整合がある可能性がある。または、テスト環境での Prisma Client のモック方法に問題がある。
            - 対応案:
              1. Prisma Client の型定義を更新するため `npx prisma generate` の実行
              2. 実際の Prisma スキーマに合わせてインポート文を修正
              3. モック実装を `tests/setup.ts` で正しく設定

### Phase 4: 継続的改善と品質保証

-   **期間**: 継続的
-   **責任者**: 開発チーム全体、QAチーム、セキュリティ担当者
-   **全体ステータス**: 未着手
-   **目的**: アプリケーションの品質、セキュリティ、パフォーマンスを継続的に監視し、改善していく体制を構築する。

    -   **BP_P4_T1: TypeScript型システムの活用強化**
        -   **説明**: アプリケーション全体でより厳密な型定義を適用し、Zodスキーマと連携して型安全性を最大限に高める。フロントエンドとバックエンド間での型定義の共有方法を確立する。
        -   **優先度**: 高 (継続的)
        -   **担当者**: 開発チーム全体
        -   **具体的なアクション**:
            1.  `any` 型や `unknown` 型の使用を最小限に抑え、具体的な型を定義する。
            2.  ZodスキーマからTypeScriptの型を自動生成する仕組み（例: `z.infer<typeof schema>`）を積極的に活用。
            3.  APIのRequest/Responseの型、データベースのエンティティ型などを明確に定義し、必要に応じて共有パッケージなどで管理。
            4.  Prismaが生成する型を適切に利用・拡張する。
        -   **期待される効果**: コンパイル時のエラー検出能力向上。リファクタリング時の安全性向上。コードの可読性とドキュメント性の向上。
        -   **ステータス**: 未着手
    -   **BP_P4_T2: セキュリティ監査の実施**
        -   **説明**: 定期的に手動および自動のセキュリティ監査を実施し、潜在的な脆弱性を特定・修正する。
        -   **優先度**: 高 (定期的: 例: 半年ごと、または大きな機能変更後)
        -   **担当者**: セキュリティ担当者、開発チーム
        -   **具体的なアクション**:
            1.  OWASP Top 10などの一般的な脆弱性チェックリストに基づいて監査。
            2.  依存ライブラリの脆弱性スキャン（例: `npm audit`, Snyk）。
            3.  SQLインジェクション、XSS、CSRF等の一般的なウェブアプリケーション脆弱性の検査。
            4.  認証・認可ロジックの検証。
            5.  発見された脆弱性に対する修正計画の策定と実施。
        -   **期待される効果**: セキュリティリスクの低減。ユーザーデータの保護。
        -   **ステータス**: 未着手
    -   **BP_P4_T3: パフォーマンステストの定期実行**
        -   **説明**: 主要なAPIエンドポイントやユースケースに対して定期的なパフォーマンステスト（負荷テスト、ストレステスト）を実施し、性能ボトルネックを特定・改善する。
        -   **優先度**: 中 (定期的: 例: リリース前、またはインフラ変更後)
        -   **担当者**: QAチーム、バックエンド開発者
        -   **具体的なアクション**:
            1.  テスト対象とするAPIエンドポイントと性能目標（例: RPS、平均応答時間）を定義。
            2.  負荷テストツール（例: k6, Artillery, JMeter）を選定・導入。
            3.  テストシナリオを作成し、自動実行できる環境を整備。
            4.  テスト結果を分析し、ボトルネックとなっている箇所（DBクエリ、特定の処理ロジック等）を特定し改善。
        -   **期待される効果**: システムの安定性とスケーラビリティの確保。ユーザーエクスペリエンスの向上。
        -   **ステータス**: 未着手
    -   **BP_P4_T4: 不要ファイルの整理と削除**
        -   **説明**: プロジェクト内に残存する不要なファイル（古いバージョンのコード、一時的なテストファイル、デッドコード等）を定期的に棚卸しし、削除することでコードベースをクリーンに保つ。
        -   **優先度**: 中 (継続的)
        -   **担当者**: 開発チーム全体
        -   **具体的なアクション**:
            1.  定期的なコードレビューや静的解析ツールを利用してデッドコードを検出。
            2.  バージョン管理システム（Git）の履歴を適切に活用し、古いブランチや不要な実験的コードを整理。
            3.  Supabase移行後に完全に不要となったFirebase関連の残存ファイルがないか最終確認。
        -   **期待される効果**: コードベースの可読性向上。ビルド時間の短縮。潜在的なバグや混乱の元となる要素の排除。
        -   **ステータス**: 未着手

## 5. リスク管理

-   **高リスク項目**:
    -   **認証システム変更による既存ユーザー影響**:
        -   **対策**: Supabaseへのユーザーデータ移行手順（特にパスワードリセット）を明確にし、ユーザーへの十分な事前告知とサポート体制を準備。段階的な移行やロールバック計画を策定。
    -   **データベーススキーマ変更**:
        -   **対策**: Prisma Migrateを慎重に利用し、ステージング環境での十分なテストを実施。データ損失が発生しないようバックアップ戦略を確立。
    -   **API互換性の維持**:
        -   **対策**: フロントエンドチームとの密な連携。APIコントラクト（OpenAPI等）を定義し、変更管理を徹底。結合テストを強化。
-   **中リスク項目**:
    -   **開発チームの学習コスト**:
        -   **対策**: Supabase、Zod、新しい設計パターン等に関する学習リソースの提供とペアプログラミング等のOJT機会を設定。
    -   **パフォーマンス劣化**:
        -   **対策**: 各フェーズの主要な変更後にパフォーマンステストを実施し、早期にボトルネックを発見・対処。
    -   **外部依存関係の変更 (Supabase仕様変更等)**:
        -   **対策**: Supabaseのリリースノートやコミュニティ情報を定期的に確認し、破壊的変更に備える。アダプターパターンなどを活用し、外部サービスへの直接依存を疎結合にする設計を検討。

## 6. リソース要件（案）

-   **人的リソース**:
    -   バックエンド開発者: 2-3名 (TypeScript, Node.js, Express.js, Prisma, SQLの経験者)
    -   バックエンドアーキテクト: 1名 (Phase 3以降、設計レビューと技術的リーダーシップ)
    -   QAエンジニア: 1名 (テスト計画・実施、品質保証)
    -   プロジェクトマネージャー: 1名 (進捗管理、コミュニケーション調整)
-   **技術リソース**:
    -   開発環境: 各開発者のローカルマシン (Node.js, pnpm, Docker, Supabase CLI)
    -   テスト環境: Supabaseプロジェクトのステージング環境（または同等のテスト用インスタンス）
    -   CI/CDパイプライン: 既存のものを拡張 (GitHub Actions, GitLab CIなど)
    -   プロジェクト管理ツール: JIRA, Asana, Trello等
    -   ドキュメント管理ツール: Confluence, Notion等

## 7. スケジュール概要（案）

-   **Phase 1 (基本機能の安定化)**: Week 1-2
    -   Week 1: BP_P1_T1 の主要ファイル修正、BP_P1_T2 開始
    -   Week 2: BP_P1_T1 残り修正、BP_P1_T2, BP_P1_T3 完了、Phase 1テストとレビュー
-   **Phase 2 (アーキテクチャの整備)**: Week 3-5
    -   Week 3: BP_P2_T1 (Supabase認証一本化) 開始、BP_P2_T2 (共通エラーハンドリング)
    -   Week 4: BP_P2_T1 完了、BP_P2_T3 (バリデーション統一)、BP_P2_T5 (PrismaClientシングルトン)
    -   Week 5: BP_P2_T4 (環境変数厳格化)、Phase 2テストとレビュー
-   **Phase 3 (高度な最適化と拡張性向上)**: Week 6-9
    -   Week 6: BP_P3_T1 (DI検討)、BP_P3_T2 (基盤クラス検討) のPoCまたは設計
    -   Week 7: BP_P3_T5 (非同期処理統一)、BP_P3_T6 (テスト戦略再構築) 開始
    -   Week 8: BP_P3_T3 (APIドキュメント整備) 開始、BP_P3_T6 継続
    -   Week 9: BP_P3_T4 (Edge Functions検討)、Phase 3残タスク完了、総合テストと最適化
-   **Phase 4 (継続的改善と品質保証)**: プロジェクト完了後、継続的に実施

(週単位の詳細はプロジェクトの進捗とリソース状況に応じて柔軟に見直す)

## 8. 承認と次のステップ

-   **承認事項**:
    1.  本プロジェクト計画書の内容とスコープの承認。
    2.  提案されたリソース配分（人的・技術的）の承認。
    3.  Phase 1 のタスク開始承認。
-   **次のステップ**:
    1.  プロジェクト関係者（開発チーム、フロントエンドチーム、プロダクトオーナー等）への本計画の説明会を実施し、質疑応答と合意形成を行う。
    2.  各開発者のローカル開発環境およびSupabaseテスト環境の準備状況を確認・整備する。
    3.  Phase 1 の各タスクについて、より詳細な作業手順と担当者を明確にし、プロジェクト管理ツールに登録する。
    4.  プロジェクトキックオフミーティングを開催し、チーム全体の目標意識を統一する。

---
**注記**: この計画書は2025年5月18日時点の分析に基づいて作成されており、実装過程で発見される追加の課題や状況の変化に応じて、内容は適宜見直され、更新されるものとします。各フェーズの完了時には、成果物のレビューと次フェーズへの移行判断を関係者間で行います。
